(let manager:make (fun () (...)))
(let _check_valid (fun (callback) (...)))
(let on (fun (typ callback) (...)))
(let emitWith (fun (val typ) (...)))
(let emit (fun (typ) (...)))
(let removeListenersOfType (fun (typ) (...)))
(let throw (fun (_x) (...)))
(let return (fun (_y) (...)))
(let try (fun (_either _continue _handle) (...)))
(let compose (fun (_f _g) (...)))
(let left (fun (_x) (...)))
(let right (fun (_y) (...)))
(let flip (fun (_f) (...)))
(let identity (fun (_x) (...)))
(let recombine (fun (_f _g _h) (...)))
(let writeFile (fun (_name _content) (...)))
(let appendToFile (fun (_name _content) (...)))
(let readFile (fun (_name) (...)))
(let fileExists? (fun (_name) (...)))
(let listFiles (fun (_path) (...)))
(let dir? (fun (_path) (...)))
(let makeDir (fun (_path) (...)))
(let removeFile (fun (_path) (...)))
(let eval (fun (f) (...)))
(let reverse (fun (_L) (...)))
(let find (fun (_L _x) (...)))
(let slice (fun (_L _start _end _step) (...)))
(let sort (fun (_L) (...)))
(let fill (fun (_val _count) (...)))
(let size (fun (_L) (...)))
(let setAt (fun (_L _index _x) (...)))
(let forEach (fun (_L _func) (...)))
(let product (fun (_L) (...)))
(let sum (fun (_L) (...)))
(let min (fun (_L) (...)))
(let max (fun (_L) (...)))
(let drop (fun (_L _n) (...)))
(let dropWhile (fun (_L _f) (...)))
(let filter (fun (_L _f) (...)))
(let map (fun (_L _f) (...)))
(let reduce (fun (_L _f) (...)))
(let flatten (fun (_L) (...)))
(let flatMap (fun (_L _f) (...)))
(let take (fun (_L _n) (...)))
(let takeWhile (fun (_L _f) (...)))
(let partition (fun (_L _f) (...)))
(let unzip (fun (_L) (...)))
(let zip (fun (_a _b) (...)))
(let zipWithIndex (fun (_L) (...)))
(let foldLeft (fun (_L _init _f) (...)))
(let forAll (fun (_L _f) (...)))
(let any (fun (_L _f) (...)))
(let countIf (fun (_L _f) (...)))
(let iterate (fun (_init _f _length) (...)))
(let iota (fun (_init _length) (...)))
(let chunkBy (fun (_L _length) (...)))
(let insert (fun (_L _index _value) (...)))
(macro -> (arg fn1 ...fns) (...))
(macro partial (func ...defargs) (...))
(macro partial2 (call ...args) (...))
(macro unless (cond ...body) (...))
(macro until (cond body) (...))
(let exp (fun (_x) (...)))
(let ln (fun (_x) (...)))
(let ceil (fun (_x) (...)))
(let floor (fun (_x) (...)))
(let round (fun (_x) (...)))
(let NaN? (fun (_x) (...)))
(let Inf? (fun (_x) (...)))
(let cos (fun (_x) (...)))
(let sin (fun (_x) (...)))
(let tan (fun (_x) (...)))
(let arccos (fun (_x) (...)))
(let arcsin (fun (_x) (...)))
(let arctan (fun (_x) (...)))
(let cosh (fun (_x) (...)))
(let sinh (fun (_x) (...)))
(let tanh (fun (_x) (...)))
(let acosh (fun (_x) (...)))
(let asinh (fun (_x) (...)))
(let atanh (fun (_x) (...)))
(let pi <value>)
(let e <value>)
(let tau <value>)
(let Inf <value>)
(let NaN <value>)
(let abs (fun (_x) (...)))
(let even (fun (_n) (...)))
(let odd (fun (_n) (...)))
(let min (fun (_a _b) (...)))
(let max (fun (_a _b) (...)))
(let pow (fun (_x _a) (...)))
(let sqrt (fun (_x) (...)))
(let fibo (fun (n) (...)))
(let prime? (fun (n) (...)))
(let divs (fun (n) (...)))
(let log (fun (x n) (...)))
(let log2 (fun (x) (...)))
(let log10 (fun (x) (...)))
(let floordiv (fun (a b) (...)))
(let complex (fun (real imag) (...)))
(let complex-add (fun (_c0 _c1) (...)))
(let complex-sub (fun (_c0 _c1) (...)))
(let complex-mul (fun (_c0 _c1) (...)))
(let complex-conjugate (fun (_c) (...)))
(let complex-module (fun (_c) (...)))
(let complex-div (fun (_c0 _c1) (...)))
(let clamp (fun (_x _min _max) (...)))
(let lerp (fun (_x _v0 _v1) (...)))
(let range (fun (i _b) (...)))
(let forEach (fun (_r _f) (...)))
(let filter (fun (_range _fun) (...)))
(let map (fun (_range _fun) (...)))
(let reduce (fun (_range _fun) (...)))
(let find (fun (_str _sub) (...)))
(let findAfter (fun (_str _sub _after) (...)))
(let removeAt (fun (_str _index) (...)))
(let ord (fun (_str) (...)))
(let chr (fun (_str) (...)))
(let setAt (fun (_str _index _x) (...)))
(let toLower (fun (text) (...)))
(let toUpper (fun (_string) (...)))
(let reverse (fun (_string) (...)))
(let slice (fun (_string _startingIndex _length) (...)))
(let split (fun (_string _separator) (...)))
(let replace (fun (_string _pattern _new) (...)))
(let join (fun (_list _delim) (...)))
(let stripMargin (fun (_str) (...)))
(macro switch (value case then ...cases) (...))
(let exec (fun (_command) (...)))
(let sleep (fun (_duration) (...)))
(let exit (fun (_code) (...)))
(let platform <value>)
(let args <value>)
(macro test:case (_desc _body) (...))
(macro test:expect (_cond ..._desc) (...))
(macro test:eq (_expected _expr ..._desc) (...))
(macro test:neq (_unexpected _value ..._desc) (...))
(macro test:suite (_name _body) (...))
(let home_dir (fun () (...)))
