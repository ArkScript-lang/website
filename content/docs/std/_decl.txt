Builtin (async func args...)
Builtin (await future)
(macro measureOnce (tag code) (...))
(macro bench (code times) (...))
(toString value)
(type value)
(nil? value)
(comparison a b)
(not value)
(hasField c field)
Builtin (disassemble f)
(let flag (fun (name desc) (...)))
(let value (fun (name desc default) (...)))
(let oneOf (fun (params) (...)))
(let group (fun (params) (...)))
(let parseArgs (fun (args cli) (...)))
(empty? a)
(len a)
Builtin (dict args...)
(let get (fun (_D _key) (...)))
(let add (fun (_D _key _value) (...)))
(let contains? (fun (_D _key) (...)))
(let contains <value>)
(let getOrElse (fun (_D _key _default) (...)))
(let updateOrDefault (fun (_D _key _f _default) (...)))
(let remove (fun (_D _key) (...)))
(let keys (fun (_D) (...)))
(let size (fun (_D) (...)))
(let values (fun (_D) (...)))
(let entries (fun (_D) (...)))
(let map (fun (_D _f) (...)))
(let map! (fun (_D _f) (...)))
(let forEach (fun (_D _f) (...)))
(let filter (fun (_D _f) (...)))
(let filter! (fun (_D _f) (...)))
(let copy (fun (_D) (...)))
(let update! (fun (_D _D2) (...)))
(let asJson (fun (_D) (...)))
(let manager:make (fun () (...)))
(let _check_valid (fun (callback) (...)))
(let on (fun (typ callback) (...)))
(let emitWith (fun (val typ) (...)))
(let emit (fun (typ) (...)))
(let removeListenersOfType (fun (typ) (...)))
(let throw (fun (_x) (...)))
(let return (fun (_y) (...)))
(let try (fun (_either _continue _handle) (...)))
(let compose (fun (_f _g) (...)))
(let left (fun (_x) (...)))
(let right (fun (_y) (...)))
(let flip (fun (_f) (...)))
(let identity (fun (_x) (...)))
(let recombine (fun (_f _g _h) (...)))
Builtin (print values)
Builtin (puts values)
Builtin (input prompt)
(let writeFile (fun (_name _content) (...)))
(let appendToFile (fun (_name _content) (...)))
(let readFile (fun (_name) (...)))
(let readLinesFile (fun (_name) (...)))
(let fileExists? (fun (_name) (...)))
(let listFiles (fun (_path) (...)))
(let dir? (fun (_path) (...)))
(let makeDir (fun (_path) (...)))
(let removeFile (fun (_path) (...)))
(let eval (fun (f) (...)))
(len a)
(empty? a)
(head a)
(tail a)
(@ lst i)
(@@ lst y x)
(let reverse (fun (_L) (...)))
(let find (fun (_L _x) (...)))
(let contains? (fun (_L _x) (...)))
(let slice (fun (_L _start _end _step) (...)))
(let sort (fun (_L) (...)))
(let fill (fun (_count _val) (...)))
(let size (fun (_L) (...)))
(let setAt (fun (_L _index _x) (...)))
(let stopIteration <value>)
(let forEach (fun ((ref _L) _func) (...)))
(let enumerate (fun ((ref _L) _func) (...)))
(let product (fun ((ref _L)) (...)))
(let sum (fun ((ref _L)) (...)))
(let min (fun ((ref _L)) (...)))
(let max (fun ((ref _L)) (...)))
(let median (fun ((ref _L)) (...)))
(let filter (fun ((ref _L) _f) (...)))
(let sortByKey (fun ((ref _L) _key) (...)))
(let map (fun ((ref _L) _f) (...)))
(let foldLeft (fun ((ref _L) _init _f) (...)))
(let reduce (fun ((ref _L) _f) (...)))
(let flatten (fun ((ref _L)) (...)))
(let flatMap (fun ((ref _L) _f) (...)))
(let take (fun ((ref _L) (mut _n)) (...)))
(let takeWhile (fun ((ref _L) _f) (...)))
(let drop (fun ((ref _L) _n) (...)))
(let dropWhile (fun ((ref _L) _f) (...)))
(let partition (fun ((ref _L) _f) (...)))
(let unzip (fun ((ref _L)) (...)))
(let zip (fun ((ref _a) (ref _b)) (...)))
(let zipLongest (fun ((ref _a) (ref _b) _filler) (...)))
(let zipWithIndex (fun ((ref _L)) (...)))
(let forAll (fun ((ref _L) _f) (...)))
(let any (fun ((ref _L) _f) (...)))
(let none (fun ((ref _L) _f) (...)))
(let countIf (fun ((ref _L) _f) (...)))
(let iterate (fun (_init _f _length) (...)))
(let iota (fun (_init _length) (...)))
(let chunkBy (fun ((ref _L) _length) (...)))
(let insert (fun ((ref _L) _index (mut _value)) (...)))
(let window (fun ((ref _L) _size _f) (...)))
(let transpose (fun (_L) (...)))
(let unique (fun ((ref _L)) (...)))
(let select (fun ((ref _L) (ref _indices)) (...)))
(let permutations (fun ((ref _L) _r _f) (...)))
(let permutationsWithReplacement (fun ((ref _L) _r _f) (...)))
(macro -> (arg fn1 ...fns) (...))
(macro partial (func ...defargs) (...))
(macro partial2 (call ...args) (...))
(macro unless (cond ...body) (...))
(macro until (cond body) (...))
(macro unpackPair (pair outx outy) (...))
(+ a b...)
(- a b...)
(* a b...)
(/ a b...)
(mod a b)
Builtin (random min max)
(let exp (fun (_x) (...)))
(let ln (fun (_x) (...)))
(let ceil (fun (_x) (...)))
(let floor (fun (_x) (...)))
(let round (fun (_x) (...)))
(let NaN? (fun (_x) (...)))
(let Inf? (fun (_x) (...)))
(let cos (fun (_x) (...)))
(let sin (fun (_x) (...)))
(let tan (fun (_x) (...)))
(let arccos (fun (_x) (...)))
(let arcsin (fun (_x) (...)))
(let arctan (fun (_x) (...)))
(let cosh (fun (_x) (...)))
(let sinh (fun (_x) (...)))
(let tanh (fun (_x) (...)))
(let acosh (fun (_x) (...)))
(let asinh (fun (_x) (...)))
(let atanh (fun (_x) (...)))
(let pi <value>)
(let e <value>)
(let tau <value>)
(let Inf <value>)
(let NaN <value>)
(let abs (fun (_x) (...)))
(let even? (fun (_n) (...)))
(let even <value>)
(let odd? (fun (_n) (...)))
(let odd <value>)
(let min (fun (_a _b) (...)))
(let max (fun (_a _b) (...)))
(let increment (fun (_x) (...)))
(let decrement (fun (_x) (...)))
(let negate (fun (_x) (...)))
(let pow (fun (_x _a) (...)))
(let sqrt (fun (_x) (...)))
(let fibo (fun (n) (...)))
(let prime? (fun (n) (...)))
(let divs (fun (n) (...)))
(let log (fun (x n) (...)))
(let log2 (fun (x) (...)))
(let log10 (fun (x) (...)))
(let floordiv (fun (a b) (...)))
(let complex (fun (real imag) (...)))
(let complex-add (fun (_c0 _c1) (...)))
(let complex-sub (fun (_c0 _c1) (...)))
(let complex-mul (fun (_c0 _c1) (...)))
(let complex-conjugate (fun (_c) (...)))
(let complex-module (fun (_c) (...)))
(let complex-div (fun (_c0 _c1) (...)))
(let clamp (fun (_x _min _max) (...)))
(let lerp (fun (_x _v0 _v1) (...)))
(let dotProduct (fun (_v1 _v2) (...)))
(let improvementRatioPercentage (fun (_a _b) (...)))
(let copySign (fun (_x) (...)))
(let radians (fun (_degrees) (...)))
(let degrees (fun (_radians) (...)))
(let integer? (fun (_x) (...)))
(let factorial (fun ((mut _n)) (...)))
(let binomialCoeff (fun (_n _k) (...)))
(let permutations (fun (_n _k) (...)))
(let close? (fun (_n _target) (...)))
(let euclideanDistance (fun (_a _b) (...)))
(let gcd (fun (_a _b) (...)))
(let lcm (fun (_a _b) (...)))
(let choice (fun (_L) (...)))
(let shuffle (fun ((mut _L)) (...)))
(let range (fun ((mut i) _b) (...)))
(let forEach (fun (_r _f) (...)))
(let filter (fun (_range _fun) (...)))
(let map (fun (_range _fun) (...)))
(let reduce (fun (_range _fun) (...)))
(+ a b...)
(len a)
(empty? a)
(head a)
(tail a)
(toNumber a)
(@ str i)
Builtin (format format values)
(let asciiLetters <value>)
(let asciiLowercase <value>)
(let asciiUppercase <value>)
(let digits <value>)
(let hexdigits <value>)
(let octdigits <value>)
(let printable <value>)
(let punctuation <value>)
(let whitespace <value>)
(let find (fun (_str _sub) (...)))
(let findAfter (fun (_str _sub _after) (...)))
(let removeAt (fun (_str _index) (...)))
(let ord (fun (_str) (...)))
(let chr (fun (_str) (...)))
(let setAt (fun (_str _index _x) (...)))
(let contains? (fun (_str _word) (...)))
(let containsAnyOf? (fun (_str _set_of_words) (...)))
(let emptyOrWhitespace? (fun (_str) (...)))
(let count (fun (_str _word) (...)))
(let toLower (fun (text) (...)))
(let toUpper (fun (_string) (...)))
(let reverse (fun (_string) (...)))
(let repeat (fun (_string _count) (...)))
(let slice (fun (_string _startingIndex _length) (...)))
(let split (fun (_string _separator) (...)))
(let replace (fun (_string _pattern _new) (...)))
(let join (fun (_list _delim) (...)))
(let lstrip (fun (_str) (...)))
(let rstrip (fun (_str) (...)))
(let strip (fun (_str) (...)))
(let stripMargin (fun (_str) (...)))
(let startsWith? (fun (_str _prefix) (...)))
(let endsWith? (fun (_str _suffix) (...)))
(let zfill (fun (_str _n) (...)))
(let center (fun (_str _len) (...)))
(let removePrefix (fun (_str _prefix) (...)))
(let removeSuffix (fun (_str _suffix) (...)))
(macro switch (value case then ...cases) (...))
(let exec (fun (_command) (...)))
(let sleep (fun (_duration) (...)))
(let exit (fun (_code) (...)))
(let platform <value>)
(let args <value>)
(let programName <value>)
(macro test:case (_desc _body) (...))
(macro test:expect (_cond ..._desc) (...))
(macro test:eq (_expr _expected ..._desc) (...))
(macro test:neq (_value _unexpected ..._desc) (...))
(macro test:suite (_name _body) (...))
Builtin (time )
